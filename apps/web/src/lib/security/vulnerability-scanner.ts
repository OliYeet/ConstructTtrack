/**
 * Security Scanning and Vulnerability Assessment
 * Automated security scanning and vulnerability detection system
 */

import { getLogger } from '@/lib/logging';
import * as semver from 'semver';
import { randomUUID } from 'crypto';

// Vulnerability severity levels
export enum VulnerabilitySeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

// Vulnerability categories
export enum VulnerabilityCategory {
  INJECTION = 'injection',
  AUTHENTICATION = 'authentication',
  AUTHORIZATION = 'authorization',
  SENSITIVE_DATA = 'sensitive_data',
  XML_EXTERNAL_ENTITIES = 'xml_external_entities',
  BROKEN_ACCESS_CONTROL = 'broken_access_control',
  SECURITY_MISCONFIGURATION = 'security_misconfiguration',
  XSS = 'xss',
  INSECURE_DESERIALIZATION = 'insecure_deserialization',
  KNOWN_VULNERABILITIES = 'known_vulnerabilities',
  INSUFFICIENT_LOGGING = 'insufficient_logging',
}

// Vulnerability finding
export interface VulnerabilityFinding {
  id: string;
  title: string;
  description: string;
  severity: VulnerabilitySeverity;
  category: VulnerabilityCategory;
  cwe?: string; // Common Weakness Enumeration
  cvss?: number; // Common Vulnerability Scoring System
  location: {
    file?: string;
    line?: number;
    endpoint?: string;
    parameter?: string;
  };
  evidence: string[];
  remediation: string;
  references: string[];
  discoveredAt: string;
  status: 'open' | 'fixed' | 'accepted' | 'false_positive';
}

// Security scan configuration
export interface SecurityScanConfig {
  enableStaticAnalysis: boolean;
  enableDependencyScanning: boolean;
  enableRuntimeScanning: boolean;
  enableConfigurationScanning: boolean;
  severityThreshold: VulnerabilitySeverity;
  excludePatterns: string[];
  customRules: SecurityRule[];
}

// Security rule interface
export interface SecurityRule {
  id: string;
  name: string;
  description: string;
  category: VulnerabilityCategory;
  severity: VulnerabilitySeverity;
  pattern: RegExp;
  check: (content: string, context?: any) => boolean;
  remediation: string;
}

// Security scanner class
export class SecurityScanner {
  private config: SecurityScanConfig;
  private findings: VulnerabilityFinding[] = [];
  private rules: SecurityRule[] = [];

  constructor(config: SecurityScanConfig) {
    this.config = config;
    this.initializeDefaultRules();
  }

  // Initialize default security rules
  private initializeDefaultRules(): void {
    this.rules = [
// SQL Injection patterns
       {
         id: 'sql-injection-1',
         name: 'Potential SQL Injection',
         description: 'Direct string concatenation in SQL queries',
         category: VulnerabilityCategory.INJECTION,
         severity: VulnerabilitySeverity.HIGH,
         pattern: /query\s*\+\s*['"]/gi,
        check: (content: string) => /query\s*\+\s*['"]/gi.test(content),
         remediation: 'Use parameterized queries or prepared statements',
       },

       // XSS patterns
       {
         id: 'xss-1',
         name: 'Potential XSS Vulnerability',
         description: 'Unescaped user input in HTML output',
         category: VulnerabilityCategory.XSS,
         severity: VulnerabilitySeverity.MEDIUM,
         pattern: /innerHTML\s*=\s*.*\+/gi,
        check: (content: string) => /innerHTML\s*=\s*.*\+/gi.test(content),
         remediation: 'Sanitize user input and use safe DOM manipulation methods',
       },

      // Hardcoded secrets
      {
        id: 'secrets-1',
        name: 'Hardcoded Secret',
        description: 'Potential hardcoded API key or password',
        category: VulnerabilityCategory.SENSITIVE_DATA,
        severity: VulnerabilitySeverity.CRITICAL,
        pattern: /(api[_-]?key|password|secret|token)\s*[:=]\s*['"][^'"]{8,}/gi,
        check: (content: string) => this.rules[2].pattern.test(content),
        remediation: 'Use environment variables or secure configuration management',
      },

      // Weak authentication
      {
        id: 'auth-1',
        name: 'Weak Authentication',
        description: 'Potential weak authentication implementation',
        category: VulnerabilityCategory.AUTHENTICATION,
        severity: VulnerabilitySeverity.HIGH,
        pattern: /password\s*===?\s*['"][^'"]*['"]/gi,
        check: (content: string) => this.rules[3].pattern.test(content),
        remediation: 'Use secure authentication libraries and proper password hashing',
      },

      // Insecure random
      {
        id: 'random-1',
        name: 'Insecure Random Number Generation',
        description: 'Use of Math.random() for security purposes',
        category: VulnerabilityCategory.SECURITY_MISCONFIGURATION,
        severity: VulnerabilitySeverity.MEDIUM,
        pattern: /Math\.random\(\)/gi,
        check: (content: string) => this.rules[4].pattern.test(content),
        remediation: 'Use cryptographically secure random number generators',
      },

      // Eval usage
      {
        id: 'eval-1',
        name: 'Dangerous eval() Usage',
        description: 'Use of eval() function with user input',
        category: VulnerabilityCategory.INJECTION,
        severity: VulnerabilitySeverity.HIGH,
        pattern: /eval\s*\(/gi,
        check: (content: string) => this.rules[5].pattern.test(content),
        remediation: 'Avoid eval() and use safer alternatives like JSON.parse()',
      },
    ];

    // Add custom rules from config
    this.rules.push(...this.config.customRules);
  }

  // Perform static code analysis
  async performStaticAnalysis(codebase: Map<string, string>): Promise<VulnerabilityFinding[]> {
    if (!this.config.enableStaticAnalysis) {
      return [];
    }

    const findings: VulnerabilityFinding[] = [];

    for (const [filePath, content] of codebase.entries()) {
      // Skip excluded patterns
      if (this.isExcluded(filePath)) {
        continue;
      }

      const lines = content.split('\n');

      for (const rule of this.rules) {
        const matches = content.match(rule.pattern);
        if (matches) {
          for (const match of matches) {
            const lineNumber = this.findLineNumber(content, match);
            
            const finding: VulnerabilityFinding = {
              id: `${rule.id}_${Date.now()}_${randomUUID().substring(0, 9)}`,
              title: rule.name,
              description: rule.description,
              severity: rule.severity,
              category: rule.category,
              location: {
                file: filePath,
                line: lineNumber,
              },
              evidence: [match],
              remediation: rule.remediation,
              references: [],
              discoveredAt: new Date().toISOString(),
              status: 'open',
            };

            findings.push(finding);
          }
        }
      }
    }

    return findings;
  }

  // Scan dependencies for known vulnerabilities
  async scanDependencies(packageJson: any): Promise<VulnerabilityFinding[]> {
    if (!this.config.enableDependencyScanning) {
      return [];
    }

    const findings: VulnerabilityFinding[] = [];

    // Known vulnerable packages (simplified - in production, use a vulnerability database)
    const knownVulnerabilities = [
      {
        package: 'lodash',
        versions: ['<4.17.21'],
        severity: VulnerabilitySeverity.HIGH,
        description: 'Prototype pollution vulnerability',
        cve: 'CVE-2021-23337',
      },
      {
        package: 'axios',
        versions: ['<0.21.1'],
        severity: VulnerabilitySeverity.MEDIUM,
        description: 'Server-Side Request Forgery vulnerability',
        cve: 'CVE-2020-28168',
      },
    ];

    const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

 for (const [packageName, versionSpec] of Object.entries(dependencies)) {
   const vulnerability = knownVulnerabilities.find(v => v.package === packageName);
   const cleaned = semver.coerce(versionSpec as string)?.version;
   if (vulnerability && cleaned && vulnerability.versions.some(range =>
     semver.satisfies(cleaned, range)
   )) {
        const finding: VulnerabilityFinding = {
          id: `dep_${packageName}_${Date.now()}`,
          title: `Vulnerable Dependency: ${packageName}`,
          description: vulnerability.description,
          severity: vulnerability.severity,
          category: VulnerabilityCategory.KNOWN_VULNERABILITIES,
          cwe: vulnerability.cve,
          location: {
            file: 'package.json',
            parameter: packageName,
          },
          evidence: [`${packageName}: ${versionSpec}`],
          remediation: `Update ${packageName} to a secure version`,
          references: [`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${vulnerability.cve}`],
          discoveredAt: new Date().toISOString(),
          status: 'open',
        };

        findings.push(finding);
      }
    }

    return findings;
  }

  // Runtime security scanning
  async performRuntimeScan(endpoints: string[]): Promise<VulnerabilityFinding[]> {
    if (!this.config.enableRuntimeScanning) {
      return [];
    }

    const findings: VulnerabilityFinding[] = [];

    for (const endpoint of endpoints) {
      // Test for common vulnerabilities
      const tests = [
        {
          name: 'SQL Injection Test',
          payload: "' OR '1'='1",
          category: VulnerabilityCategory.INJECTION,
        },
        {
          name: 'XSS Test',
          payload: '<script>alert("xss")</script>',
          category: VulnerabilityCategory.XSS,
        },
        {
          name: 'Path Traversal Test',
          payload: '../../../etc/passwd',
          category: VulnerabilityCategory.BROKEN_ACCESS_CONTROL,
        },
      ];

      for (const test of tests) {
        try {
          // Simulate security test (in production, use proper security testing tools)
          const response = await this.simulateSecurityTest(endpoint, test.payload);
          
          if (this.isVulnerable(response, test)) {
            const finding: VulnerabilityFinding = {
              id: `runtime_${endpoint}_${test.name}_${Date.now()}`,
              title: `${test.name} Vulnerability`,
              description: `Endpoint vulnerable to ${test.name.toLowerCase()}`,
              severity: VulnerabilitySeverity.HIGH,
              category: test.category,
              location: {
                endpoint,
              },
              evidence: [test.payload, response.body],
              remediation: `Implement proper input validation and sanitization for ${endpoint}`,
              references: [],
              discoveredAt: new Date().toISOString(),
              status: 'open',
            };

            findings.push(finding);
          }
        } catch (error) {
          // Log error but continue scanning
          const logger = getLogger();
          logger.warn('Runtime security test failed', {
            metadata: { endpoint, test: test.name, error },
          });
        }
      }
    }

    return findings;
  }

  // Configuration security scanning
  async scanConfiguration(config: Record<string, any>): Promise<VulnerabilityFinding[]> {
    if (!this.config.enableConfigurationScanning) {
      return [];
    }

    const findings: VulnerabilityFinding[] = [];

    // Security configuration checks
    const checks = [
      {
        key: 'NODE_ENV',
        expected: 'production',
        severity: VulnerabilitySeverity.MEDIUM,
        description: 'Application not running in production mode',
      },
      {
        key: 'HTTPS_ONLY',
        expected: 'true',
        severity: VulnerabilitySeverity.HIGH,
        description: 'HTTPS not enforced',
      },
      {
        key: 'SESSION_SECRET',
        minLength: 32,
        severity: VulnerabilitySeverity.CRITICAL,
        description: 'Weak session secret',
      },
    ];

    for (const check of checks) {
      const value = config[check.key];
      let isVulnerable = false;
      let evidence = '';

      if ('expected' in check && value !== check.expected) {
        isVulnerable = true;
        evidence = `${check.key}=${value}, expected=${check.expected}`;
      } else if ('minLength' in check && check.minLength !== undefined && (!value || value.length < check.minLength)) {
        isVulnerable = true;
        evidence = `${check.key} length=${value?.length || 0}, minimum=${check.minLength}`;
      }

      if (isVulnerable) {
        const finding: VulnerabilityFinding = {
          id: `config_${check.key}_${Date.now()}`,
          title: `Configuration Issue: ${check.key}`,
          description: check.description,
          severity: check.severity,
          category: VulnerabilityCategory.SECURITY_MISCONFIGURATION,
          location: {
            parameter: check.key,
          },
          evidence: [evidence],
          remediation: `Configure ${check.key} properly`,
          references: [],
          discoveredAt: new Date().toISOString(),
          status: 'open',
        };

        findings.push(finding);
      }
    }

    return findings;
  }

  // Perform comprehensive security scan
  async performComprehensiveScan(scanData: {
    codebase?: Map<string, string>;
    packageJson?: any;
    endpoints?: string[];
    configuration?: Record<string, any>;
  }): Promise<VulnerabilityFinding[]> {
    const allFindings: VulnerabilityFinding[] = [];

    try {
      // Static analysis
      if (scanData.codebase) {
        const staticFindings = await this.performStaticAnalysis(scanData.codebase);
        allFindings.push(...staticFindings);
      }

      // Dependency scanning
      if (scanData.packageJson) {
        const depFindings = await this.scanDependencies(scanData.packageJson);
        allFindings.push(...depFindings);
      }

      // Runtime scanning
      if (scanData.endpoints) {
        const runtimeFindings = await this.performRuntimeScan(scanData.endpoints);
        allFindings.push(...runtimeFindings);
      }

      // Configuration scanning
      if (scanData.configuration) {
        const configFindings = await this.scanConfiguration(scanData.configuration);
        allFindings.push(...configFindings);
      }

      // Filter by severity threshold
      const filteredFindings = allFindings.filter(
        finding => this.getSeverityScore(finding.severity) >= this.getSeverityScore(this.config.severityThreshold)
      );

      this.findings.push(...filteredFindings);

      // Log scan results
      const logger = getLogger();
      logger.info('Security scan completed', {
        metadata: {
          totalFindings: filteredFindings.length,
          critical: filteredFindings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL).length,
          high: filteredFindings.filter(f => f.severity === VulnerabilitySeverity.HIGH).length,
          medium: filteredFindings.filter(f => f.severity === VulnerabilitySeverity.MEDIUM).length,
          low: filteredFindings.filter(f => f.severity === VulnerabilitySeverity.LOW).length,
        },
      });

      return filteredFindings;
    } catch (error) {
      const logger = getLogger();
      logger.error('Security scan failed', error);
      return [];
    }
  }

  // Helper methods
  private isExcluded(filePath: string): boolean {
    return this.config.excludePatterns.some(pattern => 
      new RegExp(pattern).test(filePath)
    );
  }

  private findLineNumber(content: string, match: string): number {
    const contentLines = content.split('\n');
    for (let i = 0; i < contentLines.length; i++) {
      if (contentLines[i].includes(match)) {
        return i + 1;
      }
    }
    return 1;
  }

  private async simulateSecurityTest(endpoint: string, payload: string): Promise<{ body: string; status: number }> {
    // Simulate security test - in production, use proper security testing tools
    return {
      body: `Test response for ${payload}`,
      status: 200,
    };
  }

private isVulnerable(response: { body: string; status: number }, test: any): boolean {
    // More sophisticated detection based on test type
    switch (test.category) {
      case VulnerabilityCategory.INJECTION:
        // Check for SQL error messages or unexpected data exposure
        return /SQL|syntax|mysql|postgres|oracle|sqlite/i.test(response.body) ||
               response.status === 500;
      
      case VulnerabilityCategory.XSS:
        // Check if script tags are reflected without encoding
        return response.body.includes(test.payload) && 
               !response.body.includes('&lt;script&gt;');
      
      case VulnerabilityCategory.BROKEN_ACCESS_CONTROL:
        // Check for sensitive file content patterns
        return /root:|daemon:|bin:/i.test(response.body) ||
               response.status === 200 && test.payload.includes('../');
      
      default:
        return false;
    }
   }

  private getSeverityScore(severity: VulnerabilitySeverity): number {
    switch (severity) {
      case VulnerabilitySeverity.LOW:
        return 1;
      case VulnerabilitySeverity.MEDIUM:
        return 2;
      case VulnerabilitySeverity.HIGH:
        return 3;
      case VulnerabilitySeverity.CRITICAL:
        return 4;
      default:
        return 0;
    }
  }

  // Get scan results
  getFindings(): VulnerabilityFinding[] {
    return this.findings;
  }

  // Generate security report
  generateSecurityReport(): {
    summary: Record<string, number>;
    findings: VulnerabilityFinding[];
    recommendations: string[];
  } {
    const summary = {
      total: this.findings.length,
      critical: this.findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL).length,
      high: this.findings.filter(f => f.severity === VulnerabilitySeverity.HIGH).length,
      medium: this.findings.filter(f => f.severity === VulnerabilitySeverity.MEDIUM).length,
      low: this.findings.filter(f => f.severity === VulnerabilitySeverity.LOW).length,
    };

    const recommendations = [
      'Implement regular security scanning in CI/CD pipeline',
      'Keep dependencies up to date',
      'Use static analysis tools in development',
      'Implement proper input validation and sanitization',
      'Follow secure coding practices',
      'Regular security training for development team',
    ];

    return {
      summary,
      findings: this.findings,
      recommendations,
    };
  }
}

// Default security scan configuration
export const defaultSecurityScanConfig: SecurityScanConfig = {
  enableStaticAnalysis: true,
  enableDependencyScanning: true,
  enableRuntimeScanning: false, // Disabled by default for safety
  enableConfigurationScanning: true,
  severityThreshold: VulnerabilitySeverity.LOW,
  excludePatterns: [
    'node_modules/',
    '.git/',
    'dist/',
    'build/',
    '*.test.ts',
    '*.spec.ts',
  ],
  customRules: [],
};

// Global security scanner instance
export const securityScanner = new SecurityScanner(defaultSecurityScanConfig);
